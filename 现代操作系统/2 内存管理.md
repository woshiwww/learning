## 一、无存储器抽象

在早期的时候，是没有存储器抽象的，每一个程序都是直接访问物理内存。如下所示，将地址1000中的内容放到寄存器1.

​		`MOV REGISTER1, 1000`

此时内存就是一个0~MAX范围的空间。

**无抽象存在的问题：** 这种情况下一个内存上不能运行两个程序，如果程序1在地址3000处存放了一个值，第二个程序会擦除掉在相同位置的所有内容。

**在不使用存储器抽象的情况下也是能运行多个程序：** 在运行另一个程序时，操作系统把当前内存中所有内容保存到磁盘，然后将下一个程序读到内存运行。只要保证在某一个时间点内存中只有一个程序就不会发生冲突。

**把物理地址暴露给程序带来的问题：**

1.  如果用户程序能够寻址内存每个字节，就会很容易破坏操作系统。
2. 不能同时执行多个程序。

## 二、虚拟内存

**虚拟技术-基本特征：**

- 大的用户空间。通过把物理内存和外存相结合，提供给用户的虚拟内存空间通常大于实际的物理内存，既实现了这两者的分离。如在32位的计算机上，理论上虚拟内存地址可以达到4G，如果操作系统的内存空间只有256MB，但是硬盘的容量可以大于4G。
- 部分交换。虚拟内存的调入和调出是对部分虚拟地址空间进行的。
- 不连续行。物理内存分配的不连续，虚拟地址空间使用的不连续。

虚拟内存：每个程序拥有自己的地址空间，这个空间被分割成多个块，每个块称作一个页或页面。每一页有连续的地址范围。这些页映射到物理内存，但是并不是所有的页都必须在内存中程序才能运行。当程序引用到的一部分不在物理内存时，有操作系统将缺失的部分装入物理内存然后重新执行失败的指令。

​		`MOV REGISTER1, 1000`

还是上面这条指令，在有虚拟内存和没有虚拟内存的计算机上操作是不同的。

**无虚拟内存：**直接将这个地址送到内存总线，使用物理地址为1000中的内容。

**有虚拟内存：**这个地址被送到内存管理单元(MMU)，MMU把这个**虚拟地址**1000映射为 **物理内存地址** 。 

**虚拟内存 = 物理内存 + 硬盘**

### 分页

分页和分段是管理非连续内存，连续内存分配会带来一些内存碎片化问题。

<img src="https://gitee.com/one_to_one/markdown-img/raw/master/imgs/202203201404635.png" alt="image-20220320140423557" style="zoom:80%;" />

比如：有一台可以产生16位地址的计算机，**可以产生的**地址范围为0~64K-1。但是，这台计算机只有32KB的物理内存。因此虽然可以编写64KB的程序，但是不能完全放到内存上运行。而且在磁盘上必须有一个64KB程序的完整副本，来保证程序片段在需要的时候被调入内存。虚拟地址空间划分为的固定大小的块称为**页面**，在物理内存中对应的单元称为**页框**。下图所示，64KB的虚拟内存地址和32KB的物理内存，可以分为（4KB为一个块）16个页面和8个页框。

**内存和磁盘之间的交换总是以整个页面为单元进行的**。不同的机器支持的页面大小不一样，X86-64支持4KB、2MB、1GB大小的页面。

当程序访问虚拟地址0时

`MOV REG, 0`

将虚拟地址0送到MMU，MMU看到虚拟地址0落在0页面(0*4096~0*4096+4095)，页表是2，所以这一页面对应的是页框2(8192~12287)，因此MMU将虚拟地址变为8192，并把地址8192送到总线上去读写物理内存上这个位置的信息。

物理地址 = 页框*4096 + 虚拟地址 % 4096

**页面错误处理的方法：**这样并没有将程序完全放到内存上。当程序访问了一个并未映射的页面时，MMU注意到这个页面未映射用×表示，此时CPU陷入到操作系统，这个陷阱称为页面中断或页面错误，操作系统要找到一个很少使用的页框并把内容写到磁盘，然后将要访问的页面读到刚刚回收的页框中，修改映射关系(页表)，然后重新启动引起陷阱的指令。

<img src="https://gitee.com/one_to_one/markdown-img/raw/master/imgs/202203191512340.png" alt="image-20220319151154179" style="zoom:70%;" />

每个运行的程序都有一个页表，页表中各每一个内容就是页表项，页表项的结构是和机器密切相关的，但是不同的机器页表项大致相同，而且不同的计算机页表项大小也不同。

<img src="https://gitee.com/one_to_one/markdown-img/raw/master/imgs/202203191616105.png" alt="image-20220319161602045" style="zoom:80%;" />

**页框号：**这是最重要的，页映射就需要这个值。

**在/不在位：**第二重要。1表示该虚拟页在物理内存中，0表示不在，此时访问该页面会引发页面中断。

**保护位：**指出一个页面允许什么类型的访问。简单情况下只有1位，0读/写，1只读。复杂时有3位，分别表示读、写、执行该页面。

**修改和访问位：**如果一个也页面被修改过(脏的)，必须写回磁盘。如果没有被修改过(干净)，只需丢弃就行，因为它在磁盘上的副本仍有效。不论是读还是写，页面该页面被访问时都会设置访问位。这个位的值用来帮助系统在发生缺页中断时选择被淘汰的页面。

**高速缓存禁止位：**禁止该页面被高速缓存。  

## 三、页面置换算法

### （1）最近未使用页面置换算法

**最近未使用页面置换算法：**在最近的一个时钟周期内淘汰一个没有被访问的页面。在页表项中有两个位访问位和修改位，每次访问内存的时候会更新它俩的状态，一旦设置为  1，就会一直保持1直到操作系统将它复位。当一个进程启动时，所有页面的这两个位操作系统都设置为0，访问位定期清零，来区别最近没有被访问的页面。根据这两个位的值，一个页面可以分为四种情况：

- 第1类：没有访问，未修改
- 第2类：没有访问，已修改
- 第3类：有访问，未修改
- 第4类：有访问，已修改

第1类看起来似乎是不可能的，但是第3类的页面访问位被时钟中断清零后就会变成第1类。**注意：**时钟中断不会清零修改位，因为这个位在置换的时候要决定是否写回磁盘。

缺点：性能不是最好的，但是够用。

优点：易于理解和能够有效地实现。

### （2）先进先出页面置换算法

由操作系统维护一个所有当前在内存中的页面链表，先进入的放头部，后进入的放尾部。发生页面中断时淘汰头部的页面，在尾部加入新的页面。

缺点：这种方法会淘汰经常使用的页面，所以很少使用。

### （3）第二次机会页面置换算法

先进先出页面置换算法会把经常使用的置换出去，为了避免这个问题，检查头部页面的访问位，如果是0，说明这个页面老且没用，可以立刻置换掉。如果是1，则将访问位清零，然后再放到尾部，继续搜索下一个。

缺点：需要经常在链表中移动页面。

### （4）最近最少使用页面置换算法

频繁使用的页面很可能在后面使用，很久未使用的页面在未来较长时间可能仍然不会被使用。基于这个想法，在发生页面中断时，置换未使用时间最长的页面。

缺点：虽然这个算法在理论上是可以实现的，但是代价很高。

## 四、分段

段：多个相互独立的地址空间。

如果要处理在执行过程中大小有变化的数据结构，分段是一个有用的选择，还能简化链接合共享。          

分段存储管理的优点：分段有助于在几个进程之间共享过程和数据，比如共享库。

开发分页和分段的目的：

- 分页--为了得到大的线性地址空间而不必购买更大的内存。
- 分段--为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

### （1）纯分段的实现

分段和分页本质上是不同的，页面是定长的而段不是。图a是物理内存在开始时包含了5个段，用段7替换段1后会有一个空闲区，经过不断的替换后，一些块包含着段行成了空闲区，这种现象叫做棋盘形碎片或者外部碎片。空闲区的存在造成了内存浪费，可以使用内存紧缩来解决。

<img src="https://gitee.com/one_to_one/markdown-img/raw/master/imgs/202203192149718.png" alt="image-20220319214927526" style="zoom:80%;" />

### （2）分段和分页结合：Intel x86

x86处理器有16K个独立的段， 每个段可以容纳10亿个32位字。 
