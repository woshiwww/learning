**远程复制中相关模块的主要用途：**

- 类快照模块(Snap_Mgr)的主要用途：接收RepE下发的快照管理指令，管理类快照的创建、删除、获取类快照表、类快照的内存和磁盘的管理。通知差异模块在其它逻辑节点创建快照对应的差异文件，也接收差异模块对快照表的查询结果。
- RepEngine：这是一个复制引擎模块，主要负责配置的对接，以及管理复制任务的运行。和类快照控制端之间的联系主要是，下发快照创建、删除、查询指令。
- RepS：复制数据模块，主要复制异步任务数据的读取(主端)和写入(从端)。
- RepTX：主要负责复制链路的管理，传输数据，在oROle中为ReptxMgr(管理和维护所有节点的链路状态)，在Opara和OphX中为ReptxWoeker(根据ReptxMgr推送的来链路信息，对接收的消息进行发送)。
- osnapDiff：

## 差异记录模块

功能：

- 创建类快照时，类快照创建成功后，差异记录模块会创建一个差异文件，用于记录用户的后续操作。
- 删除类快照时，差异记录模块根据osnap_mgr端的计算结果，判断是否删除差异文件和更新当前的最大类快照。
- 当用户进行增删改等操作时，差异记录模块会将这些操作记录到差异文件当中。
- 当用户获取差异数据时，RepS会提供起始和结束的快照版本号，差异记录模块会根据版本号找到对应的差异文件，这些差异记录由oPara上的RepTX传送给oPhx上的RepS模块接收处理，然后再通过oPhx上的RepTx传送给对端集群的oPhx上的RepS模块接收。

在创建差异文件时，需要使用到的数据结构有。首先在每一个物理节点上都存在一个快照差异管理数组，这个数组的大小和这个系统中olmos的个数相同，这个数组中的元素是指向快照差异逻辑节点项的指针。每个逻辑节点项包含了一个异步锁用来保护这个逻辑节点下桶的创删不会并发执行，一个读写锁用来保护桶的哈希表不会并发访问。当这个物理节点上个逻辑节点上的差异记录模块启动时，这个逻辑点会被设置成is_ready状态。is_scan_del_finished布尔变量用于查看是否完成扫描DEL状态的oscf。job表示后台的任务计数，然后还有一个哈希表，表中的每一项表示一个快照差异桶项，每个桶项分别包含了桶的id、快照的版本号、当前这个桶的快照的引用计数和差异文件的描述。

### 逻辑节点的停止

```c
1.升本地的session,当session递增之后，后台正在删除差异文件的任务感知到session发生变化便会停止
2.然后投递清理资源的任务，在清理资源时先加一个创删快照权限的互斥锁，当前线程拿到这个锁后，别的线程便不会进行更改逻辑节点的状态，保证启动和停止逻辑节点不会同时去修改逻辑节点的状态。
3.将逻辑节点的is_ready设置成false，使后面新创建的创建差异文件、删除差异文件、获取差异数据、增加差异记录等任务不会执行完成，感知到is_ready为false时直接返回。
4.加一个哈希表的写锁，使当前线程在修改哈希表时别的线程如果想写或者读阻塞。
5.遍历哈希表，摘除上面的bucket_item，等待每个bucket_item流水清空，然后释放内存。等到所有的buchet_item都释放了内存后解除哈希表的写锁，再解除快照创删的互斥锁。
6.等待job计数归零，然后通知JNL清理工作完成，逻辑节点停止。
```



### 逻辑节点启动

```c
1.递增session
2.投递一个重载任务
3.先加一个创删快照互斥锁，防止别的线程修改逻辑节点的is_ready标记。k
4.将固化的桶id所对应的最大类快照从oscf_dir中列举出来，然后加一个哈希表的写锁，构建哈希表并生成bucket_item项，等所有的buchet_item项都创建成功，解除哈希表的写锁，再解除创删快照的互斥锁。现在进行的创删快照任务，就会将最新的快照更新到buchet_item上。
5.然后投递一个删除DEL状态的差异文件的任务，删除上一次停止时，由于session变化未执行完成的投递到后台的删除差异文件的任务。
6.启动结束
```



### 创建差异文件

在创建差异文件时，差异文件是通过LSM固化在oscf_dir中的，最大类快照信息和差异记录文件在oscf_dir中的存储状态分别通过key来进行排序，差异文件的key分别由TYPE、桶id、快照版本号构成，最大类快照的key主要由TYPE和桶id构成。在创建差异文件时，需要snap_mgr发送一个请求给差异记录模块，这个请求中主要包括了桶的id，新创建的快照版本号，逻辑节点的id和是否时全量复制等。



创建差异文件的流程：

```c
NAL接收到消息，然后递增当前逻辑节点的job计数
if is_ready == false:
	job递减
    结束
else：
	投递创建差异文件的任务，添加一个创删类快照权限的互斥锁
    if is_ready == false:
		job递减
        结束
    else：
		根据快照控制端提供的快照版本号、逻辑节点id、桶的id去oscf_dir中查找这个快照对应的oscf
		if 存在 && 不是全量复制：
            if 根据桶id和快照版本号查到了oscf：
                说明，之前已经创建过这个文件，只是由于某些原因而停止了。
			else：
                则之前没有创建过这个差异文件，需要新创建一个，并下盘到oscf_dir中
            对逻辑节点上的哈希表加锁
            if 通过桶id查不到对应的buket_item：
                新增一个buchet_item到哈希表中
            else：
                if snap_ver不相等：
                    创建一个临时变量，保存老的buchet_item,然后用新的buchet_item去替换哈希表中的item
                else：
                    则说明当前哈希表中的buchet_item是最新的，可以继续使用这个buchet_item
            if 全量复制标记==true：
                更新oscf中的seqno，并下盘。
            if 存在老的buchet_item：
                等待它流水清空后再将其内存释放。
	解除创建快照权限的互斥锁。
递减job计数
结束
```

### 删除差异文件

删除差异文件时，也需要snap_mgr提供相应的信息，主要包括，桶的id和逻辑节点的id，可删除oscf的起始快照版本和结束的快照版本，并提供一个当前的最大类快照版本号是否有效的标记，如果无效，则这个桶不需要记录差异数据，这个桶上所有的差异文件都可以删除。

删除差异文件的流程：

```c
接收到快照控制端下发的删除差异文件的消息
增加任务计数
if is_ready == false：
    递减任务计数
    结束
else：
    投递删除差异文件任务，并增加一个创删类快照权限的互斥锁
    if is_ready == false：
    	递减任务计数
   		结束
    else：
        if is_max_valid == true：
            if is_del_oscf == true：
                通过桶的id在oscf_dir下列举提供起始和结束的快照版本号对应的差异文件，将他们置为DEL状态，然后构建一个DEL链表
            else：
                根据提供的桶id和最大快照版本号，在oscf_dir中找到对应的oscf
                对olmos上的哈希表加写锁
                if 通过桶id找到对应的bucket_item && 快照版本号相等：
                    解除哈希写锁
                else：
                    则说明，可能删除类快照的时候，将最大类快照删除了
                    保存老的buchet_item,用新的去更新这个哈希表
                    解除哈希表的写锁
                if 存在老的buchet_itme：
                    更新oscf_dir中最大类快
                    等待老的流水清空，然后释放内存
		else：
            此时最大快照版本号无效，说明这个桶不需要差异记录
            对这个逻辑节点端的哈希表加写锁
            通过提供的桶id找到这个buchet_item,并将它从哈希表摘除
			解除哈希表的写锁
			等待这个buchet_item的流水清空，然后释放内存
			列举这个桶下所有的oscf，将ADD状态的置为DEL状态，然后构建一个DEL链表，并且删除oscf_dir中的最大类快照
if 存在DEL链表：
	投递到后台删除
任务计数递减
返回结果
```



### 增加差异记录

增加差异记录需要在已经创建好的oscf中，添加新的信息，主要包括新增加差异记录的类型、对象的名字、对象的大小等。

```c
ossa上报差异记录
if is_read==true：
加一个逻辑节点哈希表的读锁
    根据桶id找到对应的buchet_item
    增加这个桶当前快照的引用计数
    设置需要记录差异数据
解除读锁
if 需要差异记录==true：
    从tp分配mhdl,记录差异数据
返回    
```

### 获取差异数据

获取差异数据时，要提供快照的起始版本号和结束版本号，复制方式有两种，分别是全量复制和增量复制，在快照差异断点结构体中，主要包括了，断点类型的信息和占用长度。然后还有一个增量复制和全量复制的结构体。获取差异数据的主要过程为

```c
RepS发送获取差异数据的请求，然后增加当前逻辑节点的任务计数
    判断接收到的快照的起始版本号和结束版本号是否在oscf_dir中是否存在。
    如果存在，再判断起始版本号的值，如果起始版本号的值等于0，则需要全量复制，将结束快照版本号对应的差异文件的seqno作为全局的		seqno,然后复制seqno<= 这个全局seqno的对象
    如果起始版本号不为0，则需要增量复制：
    	在oscf_dir中获取提供的快照版本号区间内的差异文件，读取差异文件所对应的对象
最后完成之后需要对这个逻辑节点的任务计数递减
```

### 下次讲的内容

1. Q：oscf什么时候下盘？
   A：在创建差异文件时，通过buchet_id和osnap_ver在oscf_dir中未查找到对应的oscf时，会分配差异文件对象，然后下盘。

2. Q：全量复制时seqno什么时候加进去？
   A：在哈希表上添加了当前桶最新的buchet_item之后，判断需要全量复制时，再更新seqno。

3. Q：什么时候session加计数，不加会有什么问题？

   A：在启动逻辑节点和停止逻辑节点时会发生变化。如果不加的话，在停止逻辑节点时，会等到后台删除差异文件的任务执行完后才能停止逻辑节点。

4. Q：什么时候加锁？
   A：如果这个共享资源的使用是互斥的，即一个线程获得资源的使用权后，就会对这个资源加互斥锁，使用完后再将其进行解锁，在使用过程中，如果有其他线程想要获取该资源，那么它就会被阻塞陷入睡眠状态，直到这个资源被解锁的时候才会被唤醒。有的资源只能一个线程占用写状态，可以多个线程同时读。这种资源在使用时需要加读写锁，读写锁拥有读状态加锁、写状态加锁、不加锁三种状态，只有一个线程能占有写状态锁，可以多个线程占有读状态锁，这也是读写锁可以实现高并发的原因。当处于写状态锁下时，任何想要获得锁的线程都会被阻塞，直到写状态锁释放；如果处于读状态下，允许其他线程获得读状态锁，不允许获得写状态锁。当读写锁感知到有线程想要获得写锁时，便会阻塞气候想要获得读状态锁的线程，优先写状态锁，所以读写锁非常适合资源的读操作远多于写操作的的情况。

5. Q：创建类快照时，差异模块那边的顺序能不能交换？

   A：不能交换，如果交换，则需要先加哈希表的写锁，然后创建对应的bucket_item，然后再去查询是否存在对应的oscf，如果不存在需要创建新的oscf，再更新bucket_item，对磁盘的读写操作比较慢，如果将这部分操作放到哈希表的写锁中，会增加其他任务等待获取哈希表读写锁的时间。所以把更新bucket_item的工作放到后面，先在磁盘中查询oscf之后再来执行。

6. 框架中进程之间的关系

7. Q：逻辑节点、物理节点之间的关系

   A：逻辑节点和物理节点之间没有强绑定的关系，逻辑节点具体在哪个物理节点，是由oRole上的对应表来管理的。同一个日志组内的逻辑节点是会发生漂移的，发生飘逸的情况有两种，分别是接管和迁移。

8. Q：哪些物理节点上有哪些逻辑节点，怎么知道哪一个逻辑节点在哪一个物理节点上。

   A：通过nwatch工具查看日志视图，就能知道哪些物理节点上有哪些逻辑节点。
   
   
   
   
